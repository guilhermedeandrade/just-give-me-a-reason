import { Image, Head, Notes, Appear } from 'mdx-deck'
import { CodeSurfer, CodeSurferColumns, Step } from 'code-surfer'
import ReactAudioPlayer from 'react-audio-player';

import { nightOwl } from '@code-surfer/themes'
import customTheme from './themes/custom-theme'

import "prismjs/components/prism-reason"
import "prismjs/components/prism-typescript"

import fastpackImage from './assets/images/fastpack.png'
import reveryImage from './assets/images/revery.png'
import onivimImage from './assets/images/onivim-2.png'

import introAudio from './assets/audios/intro.m4a'

export const themes = [nightOwl, customTheme]

<Head>
  <title>Just Give Me a Reason</title>
  <meta name='twitter:card' content='summary_large_image' />
  <meta name='twitter:site' content='@ubmit' />
  <meta name='twitter:title' content='ReasonML' />
  <meta name='twitter:description' content='Just Give Me a Reason' />
</Head>

# Just Give Me a Reason

ðŸŽ·ðŸŽ·ðŸŽ·ðŸŽ·ðŸŽ·

<ReactAudioPlayer
  src={introAudio}
  controls
/>

<Notes>

First of all, I would like to have the Pink song playing on the background!
Ok, I'm going to talk a little bit about ReasonML.

</Notes>

---

## Hey there ðŸ‘‹

I'm Guilherme!

Here are some things about me

(feel free to skip this if you are not interested ðŸ˜‚)

<ul>
  <Appear>
  <li>currently addicted to smash (Rafael is guilty for this)</li>
  <li>always thinking about food</li>
  <li>I've already built more keyboards than I'd like to admit</li>
  <li>functional programming enthusiast</li>
  <li>maybe you don't know, but I'm a software engineer <a href="https://moxy.studio/">@MOXY</a></li>
  </Appear>
</ul>

___

## What is ReasonML?

<Notes>

Maybe some of you have never heard about it yet and are probably asking yourselves what is it.
Hold on a second! I'll explain everything as soon as I finish showing you some amazing things that were built using ReasonML.

</Notes>

___

## Cool stuff built with ReasonML

<ul>
  <Appear>
  <li>Facebook Messenger</li>
  <li>Fastpack</li>
  <li>Revery</li>
  <li>Onivim 2</li>
  </Appear>
</ul>

<Notes>

As far as I know, Facebook Messenger is 80% (or more) in ReasonML

</Notes>

___

<Image src={fastpackImage} />

<Notes>

The numbers speak for themselves! This is incredibly fast!

</Notes>

---

<Image src={reveryImage} />

<Notes>

It is amazing how many platforms you can reach using Revery

</Notes>

___

<Image src={onivimImage} />

<Notes>

Onivim 2 is powered by Revery - and compiled to native code. Under the hood, it uses libvim for an authentic Vim modal editing experience.

</Notes>

___

## What is ReasonML?

Again...

<Notes>

Here we are again! So, according to the official docs:
Reason is not a new language; it's a new syntax and toolchain powered by the battle-tested language, OCaml.
Reason gives OCaml a familiar syntax geared toward JavaScript programmers, and caters to the existing NPM/Yarn workflow folks already know.

For me, Reason is a pragmatic language that offers a lot of safety through its type system and immutable data structures, but it also offers escape hatches.
Also, you can think of OCaml as PT-PT and ReasonML as PT-BR.

</Notes>

___

<CodeSurfer>

```reason title="Immutable data structures"
let message = "hello";
let message = "bye";

Js.log(message) /* bye */;
```

</CodeSurfer>

<Notes>

"Immutable" as in, "doesn't change". Once a binding refers to a value,
it cannot refer to anything else (unless it explicitly contains a mutable value).
However, you may create a new binding of the same name which shadows the previous binding;
from that point onward, the binding will refer to the newly assigned value.

</Notes>

___

<CodeSurfer>

```reason title="Immutable data structures"
type person = {
  age: int,
  name: string,
};

let jorgeMartinez = {age: 900000, name: "Jorge Martinez"};
```

```reason
type person = {
  age: int,
  name: string,
};

let jorgeMartinez = {age: 900000, name: "Jorge Martinez"};

let age = 40;

let fixedJorgeMartinez = {...jorgeMartinez, age};

Js.log(fixedJorgeMartinez) /* { age: 40, name: 'Jorge Martinez' } */;
```

</CodeSurfer>

___

<CodeSurfer>

```reason
// type option('a) = None | Some('a)

type rubberDuck = {
  color: string,
  occupation: option(string),
};

let duck = {color: "purple", occupation: None};
```

```reason 3
type rubberDuck = {
  color: string,
  mutable occupation: option(string),
};
```

```reason
type rubberDuck = {
  color: string,
  mutable occupation: option(string),
};

duck.occupation = Some("witch");

Js.log(duck) /* { color: "purple", occupation: 'witch' } */;
```

</CodeSurfer>

<Notes>

By default, a Reason record is immutable. However, if you really want/need to mutate one of its properties,
you just need to add the `mutable` keyword before the property name.

</Notes>

___

<CodeSurfer>

```reason title="Immutable data structures"
let foo = ref(5);
foo := 6;

Js.log(foo) /* { contents: 6 } */;
```

```reason
type mutableVariable = {mutable contents: int};
let bar = {contents: 5};
bar.contents = 6;

Js.log(bar) /* { contents: 6 } */;
```

```reason
let baz = ref("smash");
let hulk = baz^;
baz := "bros";

Js.log(hulk) /* smash */;
Js.log(baz^) /* bros */;
```

</CodeSurfer>

<Notes>

Let-bindings are immutable, but you can wrap it with a ref, which is like a box whose content can change.
Note that `ref` is simply a syntax sugar!

</Notes>

___

<CodeSurfer>

```reason title="Variant"
type fridayLunch =
  | Pizza
  | Barbecue;

let today = Pizza;
```

```reason
type fridayLunch =
  | Pizza
  | Barbecue;

let today = Pizza;

let message =
  switch (today) {
  | Pizza => "we had pizza today!"
  | Barbecue => "we had barbecue today!"
  };

Js.log(message) /* we had pizza today*/;
```

```reason
let message =
  switch (today) {
  | Pizza => "we had pizza today!"
  | Barbecue => "we had barbecue today!"
  | Sushi => "we had sushi today!"
  };

Error: This variant pattern is expected to have type fridayLunch
       The constructor Sushi does not belong to type fridayLunch
```

</CodeSurfer>

<Notes>

Note that the compiler will complain about the `Sushi` variant, because it is not expected!
That is awesome! The compiler knows that this branch is impossible, because the `fridayLunch` type
does not contain the `Sushi` variant. This will prevent us from writing unnecessary code.

</Notes>

___

<CodeSurfer>

```reason title="Variant"
type result =
  | Loading
  | Error(string)
  | Data(array(string));
```

```reason
type result =
  | Loading
  | Error(string)
  | Data(array(string));

let result = Data([|"foo", "bar", "baz"|]);

let data =
  switch (result) {
  | Loading => "Loading..."
  | Error(error) => "Something went wrong: " ++ error
  | Data([||]) => "Array is empty!"
  | Data(array) => array->Belt.Array.length->string_of_int ++ " items in the array"
  };

Js.log(data) /* 3 items in the array */;
```

</CodeSurfer>

<Notes>

Note that if we change the order between `Data([||])`and `Data(array)` the compiler will complain
that the match case `Data([||])` is unused!

</Notes>

___

<CodeSurferColumns sizes={[1,1]}>

<Step>

```reason
type result =
  | Loading
  | Error(string)
  | Data(array(string));

type status =
  | Enabled
  | Disabled;
```

```reason
let getData = (status, result) => {
  switch (status, result) {
  | (Enabled, Loading) => "Loading..."
  | (Enabled, Error(error)) => "Something went wrong: " ++ error
  | (Enabled, Data([||])) => "Array is empty!"
  | (Enabled, Data(array)) => array->Belt.Array.length->string_of_int ++ " items in the array"
  | (Disabled, _) => "Unavailable."
  };
};

let data = getData(Disabled, Loading);

Js.log(data) /* Unavailable. */;
```

</Step>

</CodeSurferColumns>

<Notes>

I've already shown some examples of pattern matching, but those were really "simple". I mean,
most of them were something that would be possible to do using either JS or TS. However, Reason's
pattern matching really shines when we aren't matching a single Variant each time.

Trivia: Jordan Walke himself mentioned that Variants and Pattern Matching helped him a lot to figure things out 
during the first stages of Reason's development.

</Notes>

___

<CodeSurferColumns sizes={[1,1]}>

<Step>

```typescript 
interface Result {
  loading: boolean
  error: string | null
  data: string[] | null
}

interface Status {
  result: Result
  enabled: boolean
}
```

```typescript
function getData({ result, enabled }: Status) {
  if (!enabled) return 'Unavailable'
  else {
    if (result.error) return `Something went wrong: ${result.error}`
    if (result.loading) return 'Loading...'
    if (result.data && result.data.length === 0) return 'Array is empty!'
    if (result.data) return `${result.data.length} items in the array`
  }
}

const data = getData({
  result: { loading: true, error: null, data: null },
  enabled: false
})

console.log(data) // Unavailable
```

</Step>

</CodeSurferColumns>

<Notes>

Note that this is not as clean as the Reason snippet. This is not objectively a bad thing, because
I'm enforcing a style that is not built into the language. Also note that here I had to do some stuff
that was not needed in the Reason example. I had to consider the null case for both `error` and `data`,
because typescript would not let me pass the result object with `loading` only! Another bad thing here
is that not all the code paths are covered in this example, so this code is not safe!

</Notes>

___

## Trivia

Pattern matching in JavaScript is already being discuseed as a [proposal](https://github.com/tc39/proposal-pattern-matching)

