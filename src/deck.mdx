import { Head, Notes, Appear } from 'mdx-deck'
import { CodeSurfer, CodeSurferColumns, Step } from 'code-surfer'
import ReactAudioPlayer from 'react-audio-player';

import CenterImage from './components/CenterImage'

import { nightOwl } from '@code-surfer/themes'
import customTheme from './themes/custom-theme'

import "prismjs/components/prism-reason"
import "prismjs/components/prism-typescript"

import fastpackImage from './assets/images/fastpack.png'
import reveryImage from './assets/images/revery.png'
import onivimImage from './assets/images/onivim-2.png'
import prettierImage from './assets/images/prettier.png'

import introAudio from './assets/audios/intro.m4a'

import "./styles/main.css";

export const themes = [nightOwl, customTheme]

<Head>
  <title>Just Give Me a Reason</title>
  <meta name='twitter:card' content='summary_large_image' />
  <meta name='twitter:site' content='@ubmit' />
  <meta name='twitter:title' content='ReasonML' />
  <meta name='twitter:description' content='Just Give Me a Reason' />
</Head>

# Just Give Me a Reason

ðŸŽ·ðŸŽ·ðŸŽ·ðŸŽ·ðŸŽ·

<ReactAudioPlayer
  src={introAudio}
  controls
/>

<Notes>

First of all, I would like to have the Pink song playing on the background!
Ok, I'm going to talk a little bit about ReasonML.

</Notes>

---

## hey there ðŸ‘‹

I'm Guilherme!

here are some things about me

(feel free to skip this if you are not interested ðŸ˜‚)

<ul>
  <Appear>
  <li>currently addicted to smash (Rafael is guilty for this)</li>
  <li>always thinking about food</li>
  <li>I've already built more keyboards than I'd like to admit</li>
  <li>functional programming enthusiast</li>
  <li>maybe you don't know, but I'm a software engineer <a href="https://moxy.studio/">@MOXY</a></li>
  </Appear>
</ul>

___

## What is ReasonML?

<Notes>

Maybe some of you have never heard about it yet and are probably asking yourselves what is it.
Hold on a second! I'll explain everything as soon as I finish showing you some amazing things that were built using ReasonML.

</Notes>

___

## Cool stuff built with ReasonML

<ul>
  <Appear>
  <li>Facebook Messenger</li>
  <li>Fastpack</li>
  <li>Revery</li>
  <li>Onivim 2</li>
  </Appear>
</ul>

<Notes>

As far as I know, Facebook Messenger is 80% (or more) in ReasonML

</Notes>

___

<CenterImage src={fastpackImage} />

<Notes>

The numbers speak for themselves! This is incredibly fast!

</Notes>

---

<CenterImage src={reveryImage} />

<Notes>

It is amazing how many platforms you can reach using Revery

</Notes>

___

<CenterImage src={onivimImage} />

<Notes>

Onivim 2 is powered by Revery - and compiled to native code. Under the hood, it uses libvim for an authentic Vim modal editing experience.

</Notes>

___

## What is ReasonML?

Again...

<Notes>

Here we are again! So, according to the official docs:
Reason is not a new language; it's a new syntax and toolchain powered by the battle-tested language, OCaml.
Reason gives OCaml a familiar syntax geared toward JavaScript programmers, and caters to the existing NPM/Yarn workflow folks already know.

For me, Reason is a pragmatic language that offers a lot of safety through its type system and immutable data structures, but it also offers escape hatches.
Also, you can think of OCaml as PT-PT and ReasonML as PT-BR.

</Notes>

___

<CodeSurfer>

```reason title="Immutable data structures"
let message = "hello";
let message = "bye";

Js.log(message) /* bye */;
```

</CodeSurfer>

<Notes>

"Immutable" as in, "doesn't change". Once a binding refers to a value,
it cannot refer to anything else (unless it explicitly contains a mutable value).
However, you may create a new binding of the same name which shadows the previous binding;
from that point onward, the binding will refer to the newly assigned value.

</Notes>

___

<CodeSurfer>

```reason title="Immutable data structures"
type person = {
  age: int,
  name: string,
};

let jorgeMartinez = {age: 900000, name: "Jorge Martinez"};
```

```reason
type person = {
  age: int,
  name: string,
};

let jorgeMartinez = {age: 900000, name: "Jorge Martinez"};

let age = 40;

let fixedJorgeMartinez = {...jorgeMartinez, age};

Js.log(fixedJorgeMartinez) /* { age: 40, name: 'Jorge Martinez' } */;
```

</CodeSurfer>

___

<CodeSurfer>

```reason
// type option('a) = None | Some('a)

type rubberDuck = {
  color: string,
  occupation: option(string),
};

let duck = {color: "purple", occupation: None};
```

```reason 3
type rubberDuck = {
  color: string,
  mutable occupation: option(string),
};
```

```reason
type rubberDuck = {
  color: string,
  mutable occupation: option(string),
};

duck.occupation = Some("witch");

Js.log(duck) /* { color: "purple", occupation: 'witch' } */;
```

</CodeSurfer>

<Notes>

By default, a Reason record is immutable. However, if you really want/need to mutate one of its properties,
you just need to add the `mutable` keyword before the property name.

</Notes>

___

<CodeSurfer>

```reason title="Immutable data structures"
let foo = ref(5);
foo := 6;

Js.log(foo) /* { contents: 6 } */;
```

```reason
type mutableVariable = {mutable contents: int};
let bar = {contents: 5};
bar.contents = 6;

Js.log(bar) /* { contents: 6 } */;
```

```reason
let baz = ref("smash");
let hulk = baz^;
baz := "bros";

Js.log(hulk) /* smash */;
Js.log(baz^) /* bros */;
```

</CodeSurfer>

<Notes>

Let-bindings are immutable, but you can wrap it with a ref, which is like a box whose content can change.
Note that `ref` is simply a syntax sugar!

</Notes>

___

<CodeSurfer>

```reason title="Variant"
type fridayLunch =
  | Pizza
  | Barbecue;

let today = Pizza;
```

```reason
type fridayLunch =
  | Pizza
  | Barbecue;

let today = Pizza;

let message =
  switch (today) {
  | Pizza => "we had pizza today!"
  | Barbecue => "we had barbecue today!"
  };

Js.log(message) /* we had pizza today*/;
```

```reason
let message =
  switch (today) {
  | Pizza => "we had pizza today!"
  | Barbecue => "we had barbecue today!"
  | Sushi => "we had sushi today!"
  };

Error: This variant pattern is expected to have type fridayLunch
       The constructor Sushi does not belong to type fridayLunch
```

</CodeSurfer>

<Notes>

Note that the compiler will complain about the `Sushi` variant, because it is not expected!
That is awesome! The compiler knows that this branch is impossible, because the `fridayLunch` type
does not contain the `Sushi` variant. This will prevent us from writing unnecessary code.

</Notes>

___

<CodeSurfer>

```reason title="Pattern matching"
type result =
  | Loading
  | Error(string)
  | Data(array(string));
```

```reason
type result =
  | Loading
  | Error(string)
  | Data(array(string));

let result = Data([|"foo", "bar", "baz"|]);

let data =
  switch (result) {
  | Loading => "Loading..."
  | Error(error) => "Something went wrong: " ++ error
  | Data([||]) => "Array is empty!"
  | Data(array) => array->Belt.Array.length->string_of_int ++ " items in the array"
  };

Js.log(data) /* 3 items in the array */;
```

</CodeSurfer>

<Notes>

Note that if we change the order between `Data([||])`and `Data(array)` the compiler will complain
that the match case `Data([||])` is unused!

</Notes>

___

<CodeSurfer>

```reason 1:8
type result =
  | Loading
  | Error(string)
  | Data(array(string));

type status =
  | Enabled
  | Disabled;

let getData = (status, result) => {
  switch (status, result) {
  | (Enabled, Loading) => "Loading..."
  | (Enabled, Error(error)) => "Something went wrong: " ++ error
  | (Enabled, Data([||])) => "Array is empty!"
  | (Enabled, Data(array)) =>
    array->Belt.Array.length->string_of_int ++ " items in the array"
  | (Disabled, _) => "Unavailable."
  };
};

let data = getData(Disabled, Loading);

Js.log(data) /* Unavailable. */;
```

```reason 10:20
type result =
  | Loading
  | Error(string)
  | Data(array(string));

type status =
  | Enabled
  | Disabled;

let getData = (status, result) => {
  switch (status, result) {
  | (Enabled, Loading) => "Loading..."
  | (Enabled, Error(error)) => "Something went wrong: " ++ error
  | (Enabled, Data([||])) => "Array is empty!"
  | (Enabled, Data(array)) =>
    array->Belt.Array.length->string_of_int ++ " items in the array"
  | (Disabled, _) => "Unavailable."
  };
};

let data = getData(Disabled, Loading);

Js.log(data) /* Unavailable. */;
```

```reason 21:24
type result =
  | Loading
  | Error(string)
  | Data(array(string));

type status =
  | Enabled
  | Disabled;

let getData = (status, result) => {
  switch (status, result) {
  | (Enabled, Loading) => "Loading..."
  | (Enabled, Error(error)) => "Something went wrong: " ++ error
  | (Enabled, Data([||])) => "Array is empty!"
  | (Enabled, Data(array)) =>
    array->Belt.Array.length->string_of_int ++ " items in the array"
  | (Disabled, _) => "Unavailable."
  };
};

let data = getData(Disabled, Loading);

Js.log(data) /* Unavailable. */;
```

</CodeSurfer>

<Notes>

I've already shown some examples of pattern matching, but those were really "simple". I mean,
most of them were something that would be possible to do using either JS or TS. However, Reason's
pattern matching really shines when we aren't matching a single Variant each time.

Trivia: Jordan Walke himself mentioned that Variants and Pattern Matching helped him a lot to figure things out 
during the first stages of Reason's development.

</Notes>

___

## Trivia

Pattern matching in JavaScript is already being discuseed as a [proposal](https://github.com/tc39/proposal-pattern-matching)

___

## Pipe operators

<CodeSurferColumns sizes={[1,1]}>

<Step>

```reason subtitle="Pipe first"
0 -> f       == f(0)
0 -> g(1)    == g(0, 1)
0 -> h(1, 2) == h(0, 1, 2)
0 -> Some    == Some(0)
```

```reason subtitle="Pipe forward"
0 |> f       == f(0)
0 |> g(1)    == g(1, 0)
0 |> h(1, 2) == h(1, 2, 0)
```

</Step>

</CodeSurferColumns>

<Notes>

|> is usually called 'pipe-forward'. It's a helper function that's used in the wider OCaml community,
not just ReasonML. It 'injects' the argument on the left as the last argument into the function on the right.

-> is called 'pipe-first', and it's a new syntax sugar that injects the argument on the left into the first
argument position of the function or data constructor on the right.

Note that -> is specific to BuckleScript i.e. when compiling to JavaScript.
It's not available when compiling to native and is thus not portable.

</Notes>

___

<CodeSurfer>

```reason 1:5
type person = {
  name: string,
  age: int,
  weight: option(int),
};

let validateAge = age => age > 18;

let getAge = person => person.age;

let decode = json =>
  Json.Decode.{
    name: json |> field("name", string),
    age: json |> field("age", int),
    weight: json |> optional(field("weight", int)),
  };

let parseData = json => json |> Json.parseOrRaise |> decode;

let data = {| { "name": "Guilherme", "age": 24 } |};

let withoutPipe = validateAge(getAge(parseData(data)));

let withPipeFirst = parseData(data) -> getAge 
                                    -> validateAge;

let withPipeForward = data |> parseData
                           |> getAge
                           |> validateAge

Js.log(withoutPipe) /* true */;
Js.log(withPipeFirst) /* true */;
Js.log(withPipeForward) /* true */;
```

```reason 11:16,18,20
type person = {
  name: string,
  age: int,
  weight: option(int),
};

let validateAge = age => age > 18;

let getAge = person => person.age;

let decode = json =>
  Json.Decode.{
    name: json |> field("name", string),
    age: json |> field("age", int),
    weight: json |> optional(field("weight", int)),
  };

let parseData = json => json |> Json.parseOrRaise |> decode;

let data = {| { "name": "Guilherme", "age": 24 } |};

let withoutPipe = validateAge(getAge(parseData(data)));

let withPipeFirst = parseData(data) -> getAge 
                                    -> validateAge;

let withPipeForward = data |> parseData
                           |> getAge
                           |> validateAge

Js.log(withoutPipe) /* true */;
Js.log(withPipeFirst) /* true */;
Js.log(withPipeForward) /* true */;
```

```reason 22:34
type person = {
  name: string,
  age: int,
  weight: option(int),
};

let validateAge = age => age > 18;

let getAge = person => person.age;

let decode = json =>
  Json.Decode.{
    name: json |> field("name", string),
    age: json |> field("age", int),
    weight: json |> optional(field("weight", int)),
  };

let parseData = json => json |> Json.parseOrRaise |> decode;

let data = {| { "name": "Guilherme", "age": 24 } |};

let withoutPipe = validateAge(getAge(parseData(data)));

let withPipeFirst = parseData(data) -> getAge 
                                    -> validateAge;

let withPipeForward = data |> parseData
                           |> getAge
                           |> validateAge

Js.log(withoutPipe) /* true */;
Js.log(withPipeFirst) /* true */;
Js.log(withPipeForward) /* true */;
``` 

</CodeSurfer>

<Notes>
  Note that I did not need to import the `Json` module I'm using! In this case it comes from an
  external package called `bs-json`, but this also works for local files.

  I really like the pipe operator because it lets us declare exactly how the data flow is!
</Notes>

___

<CenterImage src={prettierImage} />

<Notes>

Reason has a built-in formatter (refmt), which inspired James Long to develop Prettier

</Notes>

___

<CodeSurfer>

```reason 1 title="Built-in JSX support"
  <MyComponent foo={bar} />
  ([@JSX] MyComponent.createElement(~foo=bar, ~children=[], ()));
```

```reason 2
  <MyComponent foo={bar} />
  ([@JSX] MyComponent.createElement(~foo=bar, ~children=[], ()));
```

```reason 1
  <div foo={bar}> child1 child2 </div>;
  ([@JSX] div(~foo=bar, ~children=[child1, child2], ()));
```

```reason 2
  <div foo={bar}> child1 child2 </div>;
  ([@JSX] div(~foo=bar, ~children=[child1, child2], ()));
```

```reason 1
  <> child1 child2 </>;
  ([@JSX] [child1, child2]);
```

```reason 2
  <> child1 child2 </>;
  ([@JSX] [child1, child2]);
```

```reason 1
  <MyComponent> foo bar </MyComponent>;
  ([@JSX] MyComponent.createElement(~children=[foo, bar], ()));
```

```reason 2
  <MyComponent> foo bar </MyComponent>;
  ([@JSX] MyComponent.createElement(~children=[foo, bar], ()));
```

```reason
<MyComponent
  booleanAttribute={true}
  stringAttribute="string"
  intAttribute=1
  forcedOptional=?{Some("hello")}
  onClick={send(handleClick)}>
  <div> {ReasonReact.stringToElement("hello")} </div>
</MyComponent>
```

</CodeSurfer>

<Notes>

Reason supports JSX out of the box! You don't need Babel or anything else

</Notes>

___

## Don't take type safety for granted!

7/10 of the [Top 10 JavaScript Errors](https://rollbar.com/blog/top-10-javascript-errors/) are type errors!

___

## Things I would also talk about if I had the time...

___

## BuckleScript

<ul>
  <Appear>
  <li>Blazing fast compiler!</li>
  <li>Readable and performant JavaScript output</li>
  <li>JS inside a <code>.re</code> file using <code>@bs.raw</code></li>
  <li>Use a JS module inside a <code>.re</code> file with <code>@bs.module</code></li>
  </Appear>
</ul>

---

## ReasonReact

<ul>
  <Appear>
  <li>ReasonReact components are visually similar to React ones</li>
  <li>Nice interop with React components</li>
  <li>Easy to integrate into an existing app</li>
  <li>Be able to use React as it was initially intended to be</li>
  </Appear>
</ul>

___

## Quick interview with Gabriel Rubens

[Gabriel](https://github.com/fakenickels) is CTO [@Astrocoders](https://astrocoders.com/), a Brazilian ðŸ‡§ðŸ‡· company that is using Reason in production!

___

Se pudestes escolher a maior razÃ£o de ter escolhido Reason para desenvolver seus produtos, qual seria? 
> Bom, o principalmente motivo foi a chance de nÃ£o usar um sistema de tipos apenas como um linter poderoso mas sim como uma forma de modelar meus programas com estruturas idiomÃ¡ticas de uma linguagem robusta que ajudam a manter o type safety do programa. Quanto mais regras vc consegue codificar junto ao sistema de tipos da linguagem mais vc ganha em seguranÃ§a na hora de manter esse cÃ³digo e refatorar sem medo. Junto que Reason garante que o seu cÃ³digo tem 100% type coverage.

___

Poderias relatar sobre como foi o processo de adoÃ§Ã£o do Reason em sua empresa?
> O processo comeÃ§ou de forma gradual. Apenas usamos Reason em uma parte crÃ­tica do nosso servidor e fizemos interop do cÃ³digo Reason com o cÃ³digo JS, entÃ£o do ponto de vista dos outros arquivos Ã© como se o Reason nem estivesse lÃ¡.

___

Em que tipo de produto Ã© mais fÃ¡cil perceber os benefÃ­cios trazidos pelo Reason?
> Numa aplicaÃ§Ã£o de UI Ã© muito fÃ¡cil perceber os benefÃ­cios. Geralmente em uma aplicaÃ§Ã£o React unit testing deixa muito a desejar. Ã‰ posÃ­vel, mas nÃ£o Ã© fÃ¡cil testar as complexidades de uma aplicaÃ§Ã£o web. Com o sistema de tipos de Reason vc acaba ganhando muita seguranÃ§a e â€œtestesâ€ de graÃ§a apenas por usar ele, entÃ£o a necessidade de unit testing cai dramaticamente jÃ¡ que o compilador jÃ¡ traz muita seguranÃ§a.

___

Sentes alguma dificuldade para contratar profissionais interessados em trabalhar com Reason?
> AtÃ© que nÃ£o, programaÃ§Ã£o funcional anda bem em alta atÃ© por forte influencia do prÃ³prio React, entÃ£o todo mundo jÃ¡ anda meio interessado em usar funcional

___

O quÃ£o complexo Ã© escrever bindings para packages?
> A ideia Ã© nÃ£o escrever bindings pra tudo, somente pra o que vai te atender e ir aumentando a partir daÃ­. Um erro comum de quem comeÃ§a com Reason Ã© tentar fazer bindings extensivos e completos. O que causa um overhead muito grande. Hoje em dia o BuckleScript tem trabalhado bastante em melhorar o interop com JS entÃ£o nÃ£o Ã© muito complexo, mas exige uma mudanÃ§a de mentalidade que um dev JS comum nÃ£o estÃ¡ acostumado. FFI sempre foi comum para devs de outras linguagens, mas Ã© um tema nÃ£o muito abordado em JS.

___

Quanto Ã  experiÃªncia de desenvolvimento, podes fazer uma breve comparaÃ§Ã£o com a que tinhas ao desenvolver com JS ou TS?
> Sem dÃºvidas Ã© muito mais fÃ¡cil encontrar tooling feito em TS do que em Reason ainda. Mas o ponto forte do Reason Ã© justamente 100% de type coverage e uma linguagem funcional madura. Diferentemente do TS, Reason te garante que seu cÃ³digo estÃ¡ 100% checado pelo compilador e que ele nÃ£o vai se perder. Isso jÃ¡ Ã© um grande win e faz valer a pena a falta de tooling extensivo ainda.

___

Quanto Ã  qualidade do produto final, notas uma grande diferenÃ§a ao comparar com o que era alcanÃ§ado com JS ou TS?

Em que partes ou situaÃ§Ãµes a diferenÃ§a Ã© mais notÃ¡vel? 

> Sim, a diferenÃ§a mais notÃ¡vel que nÃ£o Ã© imediatamente percebida por quem tenta usar Reason Ã© o quÃ£o fÃ¡cil Ã© manter e refatorar uma codebase feita em Reason. A sensaÃ§Ã£o de seguranÃ§a Ã© incomparÃ¡vel.

___

Como o sistema de tipos do Reason afeta o nÃºmero de testes que realmente sÃ£o necessÃ¡rios e a forma que eles sÃ£o escritos?
> A quantidade necessÃ¡ria de testes cai drasticamente pq vc consegue codificar no sistema de tipos muitas restriÃ§Ãµes da sua regra de negÃ³cios, por isso os testes acabam podendo focar em coisas mais complexas e nÃ£o em bobabens tipo garantir que seu componente nÃ£o vai tentar renderizar um undefined ou que seu reducer nÃ£o vai aceitar uma action invÃ¡lida. Ou ainda mais, que seu GraphQL resolver no servidor nÃ£o vai consumir seu banco de dados de forma incorreta ou retornar um tipo invÃ¡lido.

___

Achas que faz sentido desenvolver landing pages usando Reason?
> Sim, sem nenhum problemas. SÃ³ que ferramentas como o Gatsby por exemplo foram construÃ­das encima de dynamic typing pq ele faz muita magia por trÃ¡s pra vc. NÃ£o Ã© errado em si, Ã© um tradeoff que vc faz.

___

Como imaginas o ecossistema de Reason daqui a 5 anos?
> Imagino um tooling fullstack bem maduro e integrado. Como Reason compila tanto pra nativo quanto pra JS vai ser possÃ­vel manter uma codebase unificada de client e server. Estamos chegando lÃ¡!